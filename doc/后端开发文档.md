# 后端开发文档 (v4.0 - 最终版)

## 1. 项目概述

本项目旨在开发一个以用户心智为中心的智能环境后端服务。系统将支持结构化的知识节点管理、具备层级上下文继承能力的AI对话，并通过AI辅助用户提炼结论、进行宏观洞察。最终目标是成为一个能放大用户思考能力的智慧伙伴，严格遵循“透明可控”与“启发而非固化”的核心产品原则。

本文档是结合了最终产品方案与前后端架构评审后的开发蓝图。

## 2. 核心架构设计原则

- **强一致性优先 (Strong Consistency First)**: AI对话的上下文获取必须**100%实时准确**，以保障用户思考的逻辑连贯性。
- **异步任务处理 (Asynchronous Task Processing)**: 所有可预见的耗时AI操作（如“全局洞察”）必须采用**异步任务模式**。
- **安全第一 (Security First)**: 用户认证与数据隔离是系统的基石。所有数据访问操作都必须强制执行基于用户身份的**授权校验**。
- **表现与逻辑解耦 (Separation of Concerns)**: 严格分离核心业务数据与UI表现层数据，保证后端模型的纯净性。“该原则主要体现在数据库层面，通过独立的 `nodes` 和 `node_ui_metadata` 表实现。为了提升前端开发效率并遵循‘响应驱动’原则，API响应体（如 `Node` 对象）会将UI元数据聚合后一并返回，这是在API设计层面上为了便捷性而做出的有意权衡。”
- **明确的API契约 (Clear API Contract)**: 项目所有API将使用**OpenAPI 3.0 (Swagger)** 规范进行定义。OpenAPI文档将作为唯一的API事实来源。API响应（尤其是错误和校验信息）必须是结构化的、面向机器可读的。
- **响应驱动的数据一致性 (Response-Driven Data Consistency)**: 所有创建 (`POST`) 或更新 (`PUT`/`PATCH`) 资源的操作，其成功的响应体**必须**返回被操作后最新的、完整的实体对象或对象列表。这使得前端可以利用响应直接、精确地更新其状态缓存，避免了额外的同步请求，是实现高性能UI的关键。
- **纵深防御 (Defense in Depth)**: 在关键路径上增加保护性限制（如递归深度），防止极端用户行为影响服务稳定性。
- **状态化的业务流程 (Stateful Business Process)**: 完整支持“AI辅助下的用户终审”等核心功能，节点的结论等关键实体必须拥有明确的状态。
- **可追溯的AI交互 (Traceable AI Interaction)**: 所有关键的AI生成操作的输入、输出及主要参数都应有记录，便于问题排查、效果优化和成本审计。

## 3. 技术选型

| 领域         | 技术/组件    | 版本   | 备注                                                       |
| ------------ | ------------ | ------ | ---------------------------------------------------------- |
| **核心框架** | Spring Boot  | 3.x    | 行业标准，生态完善。                                       |
| **ORM框架**  | MyBatis-Plus | 3.5.x  | 兼顾开发效率与复杂SQL的灵活性。                            |
| **数据库**   | PostgreSQL   |     | **关键**: 利用其强大的**递归CTE**和**全文检索(FTS)**功能。 |
| **AI集成库** | LangChain4j  |  | 简化与大语言模型的交互。                                   |
| **编程语言** | Java         |     | 长期支持版本（LTS）。                                      |

## 4. 数据库设计

### 核心业务表

| 表名                | 关键字段                                                     | 备注                                                         |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **projects**        | `id`, `user_id`, `title`                                     | 项目（画布）表。`user_id`强制数据隔离。                      |
| **nodes**           | `id`, `user_id`, `project_id`, `parent_id`, `title`, `conclusion_state` (ENUM), `ai_conclusion_draft` (TEXT), `ai_conclusion_confidence` (ENUM), `final_conclusion` (TEXT), `sibling_order` (INTEGER) | 核心节点表。- `conclusion_state`: `DRAFT`, `FINALIZED`。- `ai_conclusion_confidence`: `high`, `medium`, `low`。- **全文检索索引**: 将为 `title` 和 `final_conclusion` 字段建立。 |
| **messages**        | `id`, `user_id`, `node_id`, `role`, `content`                | 对话消息表。                                                 |
| **node_references** | `id`, `source_node_id`, `target_node_id`, `user_id`, `is_pinned` (BOOLEAN) | 节点引用关系表。                                             |

### UI与用户设置表

| 表名                    | 关键字段                                                     | 备注                                                         |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **project_ui_metadata** | `project_id`, `user_id`, `zoom`, `pan_x`, `pan_y`            | 持久化画布的视角（缩放、平移）状态。                         |
| **node_ui_metadata**    | `node_id`, `user_id`, `position_x`, `position_y`             | 存储节点的UI坐标，与核心逻辑解耦。                           |
| **user_settings**       | `user_id`, `setting_key`, `setting_value`, **`tracking_data` (JSONB)** | 存储用户偏好及行为追踪数据。- **`tracking_data`**: 用于支持“自适应引导”，例如 `{"consecutive_direct_adoptions": 5}`。 |

### 商业化与资源管理表

| 表名                    | 关键字段                                                     | 备注                           |
| ----------------------- | ------------------------------------------------------------ | ------------------------------ |
| **user_credits**        | `user_id`, `balance` (DECIMAL)                               | 记录用户的点数余额。           |
| **credit_transactions** | `id`, `user_id`, `amount`, `type` (ENUM), `related_entity_id`, `created_at` | 追踪每一次点数变动，便于审计。 |
| **insight_tasks**       | `id`, `user_id`, `status` (ENUM), `request_payload` (JSONB), `conversation_history` (JSONB), `result` (TEXT), `error_message` (TEXT) | 跟踪“全局洞察”异步任务。       |

## 5. API 接口设计

**注**: 本节内容为高级概述。所有API的精确定义（URL、方法、请求/响应结构、类型）将由项目的 **OpenAPI 3.0 (Swagger)** 契约文档提供。

### 5.1 安全与授权

所有API都必须通过Spring Security进行用户认证。在业务逻辑层，**必须对所有资源操作进行强制授权校验**，确保当前用户有权访问或修改目标资源。

**特别强调：批量操作的安全性要求**
对于所有批量操作的API（如 `PATCH /api/nodes/positions`、`POST /api/nodes` 等），业务逻辑层必须在数据库事务中遍历所有输入实体的ID，并逐一校验当前用户是否拥有权限。绝不能仅检查第一个实体就假设后续实体权限相同，这会留下严重的安全漏洞。

### 5.2 核心API

#### 项目与节点管理

- `GET /api/projects/{projectId}`: 获取项目及其所有节点的层级结构化数据。
- `POST /api/nodes`: 创建新节点。支持可选的 `ui_metadata` 参数来设置初始位置，避免创建后需要额外的位置更新请求。
- `PUT /api/nodes/{id}`: 更新节点基础信息（如`title`）。
- `PATCH /api/nodes/positions`: **(新增)** 批量更新一个或多个节点的UI坐标。用于支持前端的“防抖批量保存”策略，从根本上解决N+1请求风暴问题。
  - **请求体**: [{ "id": "...", "ui_metadata": { "position_x": ..., "position_y": ... } }, ...]
  - **响应体**: `200 OK` - 成功响应**必须**返回一个包含所有被更新节点的、最新的、完整的 `Node` 对象数组。此举是为了支持前端的“用响应更新缓存”策略，实现极致的UI性能优化。
- `PUT /api/nodes/{id}/structure`: **(已修改)** 处理节点移动（修改`parent_id`）或排序。后端根据邻居ID负责计算和维护`sibling_order`。必须内置循环引用校验。
  - **请求体**: `{ "parent_id": "...", "prev_sibling_id": "...", "next_sibling_id": "..." }`
- `DELETE /api/nodes/{id}`: 删除节点。

#### 对话与结论

- `POST /api/nodes/{id}/chat`: （支持流式响应）与节点AI对话。
- `POST /api/nodes/{id}/conclusion/finalize`: **用户终审**。将结论存入`final_conclusion`，并更新`conclusion_state`。

#### 画布与用户设置

- `PUT /api/projects/{projectId}/uistate`: 保存画布的缩放、平移状态。
- `GET /api/me/settings`: 获取用户偏好设置。
- `PUT /api/me/settings`: 更新用户偏好设置。
- `POST /api/me/settings/events`: **(新增)** 用于追踪影响“自适应引导”的用户行为。后端服务负责更新`user_settings`表中的相关计数值。
  - **请求体**: `{ "event_type": "direct_conclusion_adoption" }`

#### 搜索与引用

- `GET /api/nodes/search`: **(新增)** 节点实时搜索。
  - **实现**: 后端将利用 **PostgreSQL的全文检索(FTS)** 功能，对`nodes`表的`title`和`final_conclusion`字段建立的索引进行高效查询。
- `GET /api/nodes/{id}/backlinks`: **(新增)** 获取反向链接。
  - **实现**: 后端将查询`node_references`表，找出所有`target_node_id`为当前节点ID的记录。
- `POST /api/nodes/{id}/chat` 和 `POST /api/nodes/{id}/conclusion/finalize`:
  - **实现**: 在业务逻辑中，检查请求体是否包含`references`数组。如果存在，则执行**引用关系同步操作**：
    1. **删除现有引用**: 在数据库事务中，删除该节点（`source_node_id`）在`node_references`表中的所有现有引用记录。
    2. **创建新引用**: 根据请求中的`references`数组，为每个引用的节点ID创建新的引用关系记录。
    3. **事务保证**: 整个同步操作必须在同一个数据库事务中完成，确保引用关系与最新内容完全一致。
  - **安全性**: 必须验证`references`数组中的所有目标节点ID都属于当前用户，防止跨用户引用攻击。

### 5.3 商业化与AI高级功能

- `POST /api/insights/generate`: 启动“全局洞察”异步任务。
- `GET /api/insights/tasks/{taskId}`：获取异步任务状态和结果。
- `POST /api/insights/tasks/{taskId}`：与“苏格拉底式AI教练”进行多轮对话。
- `GET /api/me/credits`: 获取用户当前点数余额。

## 6. 关键技术实现策略

- **上下文继承 (递归CTE)**: 使用PostgreSQL的递归CTE实时向上追溯父节点结论，并设置**最大递归深度限制**。
- **循环引用校验**: 在处理节点移动的业务逻辑中，在数据库事务内向上追溯新的父路径，确保其不包含待移动节点自身。
- **基于邻居的排序逻辑 (Neighbor-Based Sorting Logic)**: **(新增)** 在处理节点排序请求时，后端将根据请求中提供的 `prev_sibling_id` 和 `next_sibling_id` 来计算并重新分配受影响节点的整数 `sibling_order` 值。该策略将排序复杂性完全保留在后端，确保了数据的一致性和稳健性。
- **原子性点数扣除**: 在`InsightService`中，使用数据库事务和行级锁确保检查余额和扣除点数的操作是原子的。
- **“苏格拉底式”AI教练实现**: 通过独立的提示词工程和有状态的对话管理来实现。

## 7. 开发路线图

**第一阶段：安全、完备的基础架构 (3-4周)**

1. **定义核心模块的OpenAPI 3.0契约**。
2. 搭建Spring Security，实现用户认证与**基于资源所有权的授权逻辑**。
3. 完成**最终版数据库设计**的迁移，包括`user_settings`表的`tracking_data`字段。
4. 实现节点的基础CRUD，特别是**基于邻居ID的 `/structure` 接口**和**批量更新的 `/positions` 接口**，并集成**循环引用校验**。
5. 实现带深度限制的递归CTE上下文查询。

**第二阶段：核心功能与AI集成 (4周)**

1. 集成LangChain4j，实现基础的流式对话和AI结论草稿生成。
2. 实现基于**PostgreSQL全文检索**的节点搜索API。
3. 完成“全局洞察”的完整后端逻辑。
4. 实现`conclusion/finalize`, `user_settings`及新增的`events`接口。

**第三阶段：打磨、测试与发布 (2-3周)**

1. 对递归查询、全文检索、高并发点数扣除、**批量更新**进行压力测试。
2. 对异步任务处理流程进行健壮性测试（失败、重试）。
3. 完善所有API的错误处理和边界条件校验，确保**响应体符合契约**。
4. 编写单元测试和集成测试，确保代码质量和安全性。