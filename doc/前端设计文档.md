## **深度思考与知识生成工具：最终前端设计文档**





### 1. 项目概述与愿景



本项目旨在打造一个以用户心智为中心的智能环境，通过结构化的对话与精准的上下文控制，辅助个人进行深度思考、知识探索和价值创造。本设计文档为实现此愿景的前端应用提供了完整的技术蓝图。



### 2. 核心架构原则



- **组件化 (Component-Driven)**: 将UI彻底拆分为独立的、可复用的组件，以实现逻辑清晰和高可维护性。
- **状态驱动视图 (State-Driven UI)**: 应用的任何UI变化都应是其内部状态变化的直接、可预测的反映。
- **关注点分离 (Separation of Concerns)**: 严格分离UI渲染、业务逻辑和状态管理。
- **用户体验优先 (User Experience First)**: 优雅地处理“失败路径”，为所有异步操作提供清晰、非侵入式的UI反馈，确保用户始终对应用状态有掌控感。
- **性能与可扩展性 (Performance & Scalability)**: 架构设计必须能够应对超大型项目的数据加载和频繁操作，通过批量处理等策略从根本上解决性能瓶颈。



### 3. 技术选型



| 类别           | 技术/库                      | 备注                                                      |
| -------------- | ---------------------------- | --------------------------------------------------------- |
| **核心框架**   | Vue 3 + TypeScript           | 官方推荐的渐进式框架，提供组件化模型和类型安全。          |
| **状态管理**   | Pinia                        | Vue官方推荐的下一代状态管理库，提供类型安全和模块化API。  |
| **服务端状态** | @tanstack/vue-query          | TanStack Query的Vue适配器，负责API数据获取、缓存和同步。  |
| **样式方案**   | Tailwind CSS                 | 与原型一致的原子化CSS框架。                               |
| **Canvas交互** | 自定义实现                   | 初期自定义实现拖拽、缩放，以完全匹配原型视觉。            |
| **API契约**    | **OpenAPI (Swagger)**        | **[新增]** 作为前后端协作的单一事实来源，保证接口一致性。 |
| **类型生成**   | openapi-typescript-codegen   | 根据OpenAPI规范自动生成TypeScript类型定义。               |
| **测试框架**   | Vitest, Cypress/Playwright   | **[新增]** 覆盖单元、集成和端到端测试，保障代码质量。     |

导出到 Google 表格



### 4. 状态管理策略



应用状态被明确分为两类，并采用不同的管理工具：

1. **全局客户端状态 (使用 Pinia)**
   - `activeNodeId`: 当前激活的节点ID。
   - `canvasViewport`: 画布的平移与缩放状态 {x, y, zoom}。
   - `dirtyNodes`: 一个`Map<nodeId, { ui_metadata: { position_x, position_y } }>`，用于暂存被移动但尚未保存的节点，以支持批量更新。
   - `systemStatus`: `'idle' | 'saving' | 'success' | 'error'`，用于驱动全局状态指示器。
2. **服务端缓存状态 (使用 @tanstack/vue-query)**
   - **核心模式："用响应更新缓存"**: 所有创建（`POST`）或更新（`PUT`/`PATCH`）操作的后端API，**必须**在其响应体中返回更新后的完整实体。前端`useMutation`的`onSuccess`回调将利用此响应数据，通过`queryClient.setQueryData`直接、精确地更新缓存，**从而避免了额外的GET请求**，实现了极致的性能优化。
   - **强一致性保障**: 对于无法返回完整实体的复杂操作，将采用`queryClient.invalidateQueries`策略，强制重新获取数据，以严格遵循后端的"强一致性优先"原则。



### 5. 关键功能实现方案





#### a. 画布与节点操作



- **节点移动 (更新位置)**
  1. 用户拖拽节点结束时 (`onDragEnd`)，**不直接调用API**，而是将节点的ID和新坐标更新到Pinia的`dirtyNodes` Map中。
  2. 使用Vue的`watch`监听`dirtyNodes`的变化，并结合`debounce`函数进行防抖处理。当用户停止操作片刻后，触发一次`useMutation`。
  3. 此`mutation`调用一个**真正的批量更新API** `PATCH /api/nodes/positions`，其请求体为一个包含所有"脏节点"信息的数组，从根本上解决了N+1请求风暴问题。
- **节点排序与重新挂载 (更新结构)**
  1. 前端**不计算任何`sibling_order`值**。排序逻辑完全由后端负责。
  2. 当用户拖拽节点至两个同级节点之间时，UI会显示一个清晰的“放置指示器”。
  3. 拖拽结束后，前端确定其**前/后邻居节点的ID** (`prev_sibling_id`, `next_sibling_id`)。
  4. 调用`PUT /api/nodes/{id}/structure`接口，将这些邻居ID作为参数发送给后端，由后端完成排序计算。



#### b. “全局洞察”与AI教练



1. 用户提交洞察请求后，前端轮询`GET /api/insights/tasks/{taskId}`接口。
2. 任务成功后，应用将展示一个专用的**“洞察详情”界面**。
3. 该界面除了展示洞察结果，还包含一个**与"苏格拉底式AI教练"对话的聊天窗口**，该窗口由`POST /api/insights/tasks/{taskId}`接口驱动，实现了产品"启发而非固化"的核心原则。



#### c. “自适应引导”



1. **状态管理**: “无修改采纳”等追踪计数器将**由后端在`user_settings`表中管理**，以确保用户体验在多设备间的一致性。前端不再使用`localStorage`进行追踪。
2. **智能Nudge (演进路径)**: 前端在用户无修改采纳结论后，调用一个专用的事件追踪API（如`POST /api/me/settings/events`）。当后端记录的计数值达到阈值时，前端获取到的用户设置中会包含一个标志，用于触发“是否开启高效模式”的主动询问。



### 6. 工程化与质量保障





#### a. 异常处理与用户体验



- **状态恢复**: 任何批量API（如`PATCH /api/nodes/positions`）调用失败时，`dirtyNodes`等暂存状态**不会被清空**。UI会提供明确的错误提示（Toast）和一个“重试”按钮，允许用户一键重新提交之前的操作，避免数据丢失。
- **异步状态反馈**: 应用将包含一个全局的`SystemStatusIndicator`组件，通过“正在保存...”、“✓ 已保存”、“保存失败”等微交互，让用户对所有后台操作的状态一目了然。



#### b. API协同契约



- **OpenAPI (Swagger) 作为单一事实来源**: 在开发前，前后端共同定义一份机器可读的API契约。
- **类型生成**: 利用`openapi-typescript-codegen`等工具从契约**自动化生成前端的TypeScript类型**，确保前后端数据结构100%同步。



#### c. 分层自动化测试



- **单元测试 (Vitest)**: 覆盖独立的工具函数和状态管理逻辑。
- **集成测试 (Vitest + MSW)**: 测试Composables与模拟API的交互，验证缓存更新逻辑。
- **端到端测试 (Cypress/Playwright)**: 模拟真实用户操作，覆盖如"拖拽节点进行重新排序并验证API调用"等关键用户旅程。

#### d. 关联引用与反向链接

- **UI交互逻辑**:
    - 监听聊天输入框中的`[[`文本，当检测到时，显示`<ReferenceSearchPopover/>`组件。
    - 输入框内容变化时，对调用API的函数进行**防抖(debounce)**处理，以优化性能。
- **状态管理 (Pinia)**:
    - 新增状态 `isReferencePopoverOpen: boolean` 来控制弹窗显隐。
    - 新增状态 `referenceSearchQuery: string` 来保存搜索关键词。
- **API集成 (@tanstack/vue-query)**:
    - 使用 `useQuery` 并传入 `referenceSearchQuery` 来调用 `GET /nodes/search` 接口。查询结果将被缓存。
    - 在聊天或结论提交时，将用户选中的节点ID存入一个数组，并作为 `references` 字段随 `POST /api/nodes/{id}/chat` 或 `POST /api/nodes/{id}/conclusion/finalize` 请求一并发送。